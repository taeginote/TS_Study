내가 프로젝트에서 사용한 tsconfig
{
    //TS 컴파일러의 옵션들을 지정하는 속성
	"compilerOptions": {
----------------------------------------------------------------------------------------------------------------------------------
        (기본 옵션)
        ⭕️사용한 것(기본 옵션)
		"target": "es6", //es3부터 es5,es6등 가장 최신 버전인 esnext까지 존재 
		"lib": ["dom", "dom.iterable", "esnext"],//타입스크립트에서 파일을 자바스크립트로 컴파일 할 때 포함될 라이브러리 목록
                                                 //es2015는 프로미스 객체를 타입스크립트에서 인식할 수 있게 필요한 속성
                                                 //dom관련 속성은 DOM APU를 사용하는 경우 필요하다                                     
		"allowJs": true,                         //JS파일 컴파일 허용
		"module": "commonjs", //JS파일간 import 문법을 구현할 때 어떤 문법을 쓸지 정하는 곳입니다.
                              //module에다가 commonjs가 국룰, 신버전 js만 표현 가능한 그런 문법들이 있는데 그건 esnext등으로 버전을 올려줘야 사용이 가능함.
        "jsx": "react-jsx" //생성될 JSX 코드 설정
        "isolatedModules": true, // 각 파일들을 별도 모듈로 변환
        ❌사용하지 않은거(기본 옵션)
        "incremental": true, //증분 컴파일 활성화 
        "checkJs": true, //.js 파일 오류 리포트 설정 
----------------------------------------------------------------------------------------------------------------------------------
        (고급 옵션)
        ⭕️사용한 것(고급 옵션)
        "skipLibCheck": true,          //선언 파일 유형 검사 스킵 
		"forceConsistentCasingInFileNames": true, //동일한 파일에 대한 일관되지 않은 케이스 참조를 허용하지 않음
----------------------------------------------------------------------------------------------------------------------------------
		(모듈 분석 옵션)
        ⭕️사용한 것 (모듈 분석 옵션)
        "esModuleInterop": true, //commonjs와 ES 모듈간의 상호 운용성을 제공, allowSyntheticDefaultImports암시
        "moduleResolution": "node", //모듈 분석 방법 설정: 'node' (node.js)또는 'classic' (TS pre-1.6)
		"allowSyntheticDefaultImports": true //기본 출력(default export)이 없는 모듈로부터 기본 호출을 허용( 이 코드는 단지 유형 검사만 수행)

        ❌사용하지 않은거 (모듈 분석 옵션)
        "types": [], /* 컴파일 시 포함될 유형 선언 파일 입력 */
        "typeRoots": [], // 유형 정의를 포함할 디렉토리 목록 */
        "baseUrl": "./", // 절대 경로 모듈이 아닌, 모듈이 기본적으로 위치한 디렉토리 설정*/
        "paths": {},     //'baseUrl'을 기준으로 상대 위치로 가오기를 다시 매핑하는 항목 설정
		"resolveJsonModule": true, // 확장자가 .json인 모듈의 import를 허용하는 설정이다.
                                   // Node.js 자바스크립트 파일에서 json설정 파일을 import해서 자주 사용한것이 있다.
                                   // 타입스크립트도 가능할것이지만 json의 프로퍼티들은 전부 타입을 지정해야 사용이 가능하다.
                                   // 이 옵션은 json의 타입을 자동으로 설정해줘서 따로 변환 작업없이 타입스크립트에서 json파일 데이터들을 곧바로 사용할 수 있도록 해준다.
                                   // 이 옵션을 통해서 자동 타입을이 매핑되어 사용 가능한것을 알수있었다.
		"noEmit": true, //타입스크립트에서 컴파일 하면 JS변환 파일을 만들어 내지 않도록 하는 설정이다.
                        // 이는 타입스크립트를 에디터 통합 기능을 제공하기 위한 도구 혹은 소스 코드 타입 체커로만 사용하게 되는 꼴이 된다.
                        // 만일 Babel이나 swc와 같은 또 다른 도구가 변환하는 작업을 대신 담당하는 경우 사용되는 옵션이라고 이해하면 된다.
---------------------------------------------------------------------------------------------------------------------------------
        (엄격한 유형 검사 옵션)
        ⭕️사용한 것 (엄격한 유형 검사 옵션)
        "strict": true, //모든 엄격한 유형 검사 옵션 활성화 

        ❌사용하지 않은거 (엄격한 유형 검사 옵션)
        "noImplicitAny": true,                 // 명시적이지 않은 'any' 유형으로 표현식 및 선언 사용 시 오류 발생 
        "strictNullChecks": true,              //  null 검사 사용 
        "strictFunctionTypes": true,           //  함수 유형 검사 사용 
        "strictBindCallApply": true,           //  'bind', 'call', 'apply' 함수 메서드 사용 
        "strictPropertyInitialization": true,  // 클래스에서 속성 초기화 엄격 검사 사용 
        "noImplicitThis": true,                // 명시적이지 않은 'any'유형으로 'this' 표현식 사용 시 오류 발생 
        "alwaysStrict": true,                  // 엄격모드에서 구문 분석 후, 각 소스 파일에 "use strict" 코드를 출력 
----------------------------------------------------------------------------------------------------------------------------------
        (추가 검사 옵션)
        ⭕️사용한 것 (추가 검사 옵션)
        "noFallthroughCasesInSwitch": true, //switch 문 오류 유형에 대한 오류 보고

        ❌사용하지 않은거 (엄격한 유형 검사 옵션)
        "noUnusedLocals": true,                // 사용되지 않은 로컬이 있을 경우, 오류로 보고 
        "noUnusedParameters": true,            // 사용되지 않은 매개변수가 있을 경우, 오류로 보고 
        "noImplicitReturns": true,             // 함수가 값을 반환하지 않을 경우, 오류로 보고 
 	    "noUncheckedIndexedAccess": true,      // 인덱스 시그니처 결과에 'undefined' 포함 
----------------------------------------------------------------------------------------------------------------------------------
	},
    //컴파일할 파일들을 지정하는 속성 (와일드 카드 패턴으로 묶어 표현)
	"include": ["src"]
}

전역 속성들은 많다. 주로 쓰이는 다섯가지 compilerOptions, files, include, exclude, extends

- files
프로젝트에서 컴파일할 파일들의 목록을 명시적으로 지정하는 속성이다,
files 속성은 밑에서 배울 exclude보다 우선순위가 높다. 만일 이 속성이 생량되면 include와 exclude속성으로 컴파일 대상을 결정한다.

- extends
extends는 다른 tsconfig파일의 설정들을 가져와 재사용할수있게 해주는 옵션이다. 보통 extends속성은 tsconfig파일의 최상위에 위치한다.

- include
include 속성은 files속성과 같이 프로젝트에서 컴파일할 파일들을 지정하는 속성이지만. 와일드 카드 패턴으로 지정하는 점에서 차이가 있다.
또한 include는 files속성과는 달리 exclude보다 약해 include에 명시되어 있어도 exclude에도 명시되어 있으면 제외 되게 된다.

- exclude
exclude 속성은 프로젝트에서 컴파일 대상에서 제외할 파일들을 와일드카드 패턴으로 지정하는 속성이다. 
즉, included의 반대 버전이라고 생각하자.

- compilerOptions
컴파일 대상 파일들을 어떻게 변환할지 세세히 정하는 옵션 


